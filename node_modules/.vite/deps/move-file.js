import {
  __commonJS,
  __toESM
} from "./chunk-LNEMQRCO.js";

// browser-external:node:process
var require_node_process = __commonJS({
  "browser-external:node:process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:process" has been externalized for browser compatibility. Cannot access "node:process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:path
var require_node_path = __commonJS({
  "browser-external:node:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:path" has been externalized for browser compatibility. Cannot access "node:path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:fs
var require_node_fs = __commonJS({
  "browser-external:node:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs" has been externalized for browser compatibility. Cannot access "node:fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/move-file/index.js
var import_node_process = __toESM(require_node_process());
var import_node_path = __toESM(require_node_path());
var import_node_fs2 = __toESM(require_node_fs());

// node_modules/move-file/node_modules/path-exists/index.js
var import_node_fs = __toESM(require_node_fs());
async function pathExists(path2) {
  try {
    await import_node_fs.promises.access(path2);
    return true;
  } catch {
    return false;
  }
}

// node_modules/move-file/index.js
var resolvePath = (cwd, sourcePath, destinationPath) => {
  sourcePath = import_node_path.default.resolve(cwd, sourcePath);
  destinationPath = import_node_path.default.resolve(cwd, destinationPath);
  return {
    sourcePath,
    destinationPath
  };
};
var validatePathsExist = (sourcePath, destinationPath, suffix = "Path") => {
  if (!sourcePath || !destinationPath) {
    throw new TypeError(`\`source${suffix}\` and \`destination${suffix}\` required`);
  }
};
var validateSameDirectory = (source, destination) => {
  if (import_node_path.default.dirname(source) !== import_node_path.default.dirname(destination)) {
    throw new Error("`source` and `destination` must be in the same directory");
  }
};
var _moveFile = async (sourcePath, destinationPath, { overwrite = true, cwd = import_node_process.default.cwd(), directoryMode, validateDirectory = false } = {}) => {
  if (cwd) {
    ({ sourcePath, destinationPath } = resolvePath(cwd, sourcePath, destinationPath));
  }
  if (validateDirectory) {
    validateSameDirectory(sourcePath, destinationPath);
  }
  if (!overwrite && await pathExists(destinationPath)) {
    throw new Error(`The destination file exists: ${destinationPath}`);
  }
  await import_node_fs2.promises.mkdir(import_node_path.default.dirname(destinationPath), {
    recursive: true,
    mode: directoryMode
  });
  try {
    await import_node_fs2.promises.rename(sourcePath, destinationPath);
  } catch (error) {
    if (error.code === "EXDEV") {
      await import_node_fs2.promises.copyFile(sourcePath, destinationPath);
      await import_node_fs2.promises.unlink(sourcePath);
    } else {
      throw error;
    }
  }
};
var _moveFileSync = (sourcePath, destinationPath, { overwrite = true, cwd = import_node_process.default.cwd(), directoryMode, validateDirectory = false } = {}) => {
  if (cwd) {
    ({ sourcePath, destinationPath } = resolvePath(cwd, sourcePath, destinationPath));
  }
  if (validateDirectory) {
    validateSameDirectory(sourcePath, destinationPath);
  }
  if (!overwrite && import_node_fs2.default.existsSync(destinationPath)) {
    throw new Error(`The destination file exists: ${destinationPath}`);
  }
  import_node_fs2.default.mkdirSync(import_node_path.default.dirname(destinationPath), {
    recursive: true,
    mode: directoryMode
  });
  try {
    import_node_fs2.default.renameSync(sourcePath, destinationPath);
  } catch (error) {
    if (error.code === "EXDEV") {
      import_node_fs2.default.copyFileSync(sourcePath, destinationPath);
      import_node_fs2.default.unlinkSync(sourcePath);
    } else {
      throw error;
    }
  }
};
async function moveFile(sourcePath, destinationPath, options) {
  validatePathsExist(sourcePath, destinationPath);
  return _moveFile(sourcePath, destinationPath, options);
}
function moveFileSync(sourcePath, destinationPath, options) {
  validatePathsExist(sourcePath, destinationPath);
  return _moveFileSync(sourcePath, destinationPath, options);
}
async function renameFile(source, destination, options = {}) {
  validatePathsExist(source, destination, "");
  return _moveFile(source, destination, { ...options, validateDirectory: true });
}
function renameFileSync(source, destination, options = {}) {
  validatePathsExist(source, destination, "");
  return _moveFileSync(source, destination, { ...options, validateDirectory: true });
}
export {
  moveFile,
  moveFileSync,
  renameFile,
  renameFileSync
};
//# sourceMappingURL=move-file.js.map
